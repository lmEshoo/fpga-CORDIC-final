{
  "name": "Fpga-cordic-final",
  "tagline": "this takes a user input and outputs the sine and cosine ( implementation on Xilinx Spartan 3E )",
  "body": "### Theory:\r\nThis was a multipart project. Where we took a complex system and divided it into smaller parts and connected them all together to make it easier to make and test. This project’s idea was to take in user input, happens to be values between +90 to -90 anglesand output the corresponding sine and cosine of the inputted angle. This was a great lab where we used Binary to BCD converter, BCD to binary converter and learned more about the CORDIC method.The CORDIC method stands for COordinate Rotation DIgital Computerand is much faster than Taylor series. What makes CORDIC fast is how it’simplemented, whenwe take a binary number and multiply it by 2n, we shift the binary point n places to the right and when we divide by 2nwe shift the binary point n places to the left.These operations are the cheapest and fastest to perform.Ihave used the CORDIC method several years back when I made a calculator using a microcontrollerand table lookupto prove that the CORDIC method is what calculator companies use to compute sine and cosine instead of Taylor Polynomials. Using CORDIC is a clear winner when a hardware multiplier is unavailable.We started off by making the input interface thatwas by taking two BCD digits from the user and converting them to binary that bytaking the most significant digit and multiplying it by 10 and adding the least significant to it. We made an array multiplier from earlier the quarter so we used that for multiplication.For the second part, we made the CORDIC module. We were given the ASM chart, just asked to code and simulateit.First time working with signed numbers, lots of conversations and keeping track of bits.Lastly, we were to put everything together. That is, take BCD from user input, convert it to binary, send it to CORDIC take the results from CORDIC and send it to Binary to BCD converter and show those on 16x2 LCD. \r\n\r\n### Testing procedure:\r\nFor the first part we simulated the array multiplier, and that’s how we tested it. Until we wrote the code for the controller that’s when we tested it on the board by implementing it. For the second part, the CORDIC module, we simulated it only. For the final part of this project, we mainly implemented it. And tested that way, we did not simulate the controller. It was easier implementing it for us.\r\n\r\n### Analysis:\r\nThe results we obtained were as expected.If we divide the numbers we get by 4096(212) we get the same result we usually get on the calculator.As we can see, the results are very close to the realvalues.We do see the results we got during simulating the CORDIC module match or closely match (for the case of cos (±45)).Therefore, the percent error is really small\r\n\r\n### Conclusions:\r\nThe last part of the labtaught me the most because actually connecting things with done and go, showing how important they are, and debugging what was wrong was great.After making all the necessary changeswith signed and unsigned signals, we were getting all the right results except for anywhere in the range of ±70 to ±79, everything else worked. So that was the most debugging we did, we started off by checking if ourBinary to BCD was giving us the right results by giving it static values, check. Then checked if our CORDIC wasworking and checked by giving it the static value again. Check, lastly we checked the array multiplier and that was not giving us the right answer. So we simulated it again. Unfortunately, when we did simulate it, we did not test all numbers. And so we simulated for all numbers so it would work for all numbers except for 7 being the ‘b’input but if we put 7 as the ‘a’inputit would work for all numbers. So we switched it, we are pretty sure that we must’ve connected some wire wrong since we did it structurally. But with that, it fixed our issue. It was great revisiting the topic of CORDIC. But what was greater is that using linked ASMs for the first time made me love designing on FPGA’s spent nights to make and understand the lab line by line. I will definitely take what I learned this quarter and apply it in the future. As I see myself doing it as a career.Besides that, CORDIC is a robust and practical algorithm.\r\n\r\n### Support or Contact\r\n@lmeshoo\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}